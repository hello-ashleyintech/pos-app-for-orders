import { BaseClient, DomainEvent } from './';
export interface DeleteAggregateResponse {
    deleteToken?: string;
}
declare type AggregateType = string;
declare type AggregateId = string;
export interface CommitOptions {
    tenantId?: string;
}
export interface RecordEventOptions {
    tenantId?: string;
}
export interface CreateAggregateOptions {
    tenantId?: string;
}
export interface LoadAggregateOptions {
    tenantId?: string;
    since?: number;
    limit?: number;
}
export interface AggregateRequest {
    aggregateId: AggregateId;
}
export interface LoadAggregateResponse extends AggregateRequest {
    aggregateVersion: number;
    events: DomainEvent<any>[];
    hasMore: false;
}
export interface CheckAggregateExistsRequest extends AggregateRequest {
}
export interface DeleteAggregateOptions {
    deleteToken?: boolean;
}
export interface DeleteAggregateRequest extends AggregateRequest {
}
export interface DeleteAggregateTypeRequest {
    aggregateType: AggregateType;
}
export interface AggregateMetadata {
    version: number;
}
export interface Commit {
    events: DomainEvent<any>[];
    expectedVersion?: number;
}
declare class AggregatesClient<A> extends BaseClient {
    private aggregateTypeConstructor;
    private readonly aggregateType;
    private readonly stateLoader;
    constructor(aggregateTypeConstructor: any, config: any);
    checkExists(request: CheckAggregateExistsRequest): Promise<any>;
    update(aggregateId: string, commandHandler: (s: A) => DomainEvent<any>[]): Promise<number>;
    create(aggregateId: string, commandHandler: (s: A) => DomainEvent<any>[], options?: CreateAggregateOptions): Promise<number>;
    commit(aggregateId: string, commandHandler: (s: A) => Commit, options?: CommitOptions): Promise<number>;
    recordEvent(aggregateId: string, event: DomainEvent<any>, options?: RecordEventOptions): Promise<number>;
    recordEvents(aggregateId: string, events: DomainEvent<any>[], tenantId?: string): Promise<number>;
    load<T extends A>(aggregateId: string, options?: LoadAggregateOptions): Promise<T>;
    private loadInternal;
    deleteAggregate(request: DeleteAggregateRequest, options?: DeleteAggregateOptions): Promise<DeleteAggregateResponse | void>;
    deleteAggregateType(request: DeleteAggregateTypeRequest, options?: DeleteAggregateOptions): Promise<DeleteAggregateResponse | void>;
    private saveInternal;
    static aggregateEventsUrlPath(aggregateType: string, aggregateId: string): string;
    static aggregateUrlPath(aggregateType: string, aggregateId: string): string;
    static aggregateTypeUrlPath(aggregateType: string): string;
    get initialState(): any;
}
export { AggregatesClient };
