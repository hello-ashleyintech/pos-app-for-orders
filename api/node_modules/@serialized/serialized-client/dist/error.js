"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Type guard to check if the thrown error is a SerializedError
 */
exports.isSerializedError = function (error) {
    return error.isSerializedError === true;
};
/**
 * Base type for all errors thrown by the Serialized client
 */
var SerializedError = /** @class */ (function (_super) {
    __extends(SerializedError, _super);
    function SerializedError(message) {
        var _this = _super.call(this, message) || this;
        _this.isSerializedError = true;
        return _this;
    }
    return SerializedError;
}(Error));
exports.SerializedError = SerializedError;
/**
 * Type guard to check if the thrown error is a SerializedApiError
 */
exports.isSerializedApiError = function (error) {
    return error.isSerializedApiError === true;
};
/**
 * Thrown when the API returns an error code. This is normally wrapped by the client classes to more use-case specific errors.
 */
var SerializedApiError = /** @class */ (function (_super) {
    __extends(SerializedApiError, _super);
    function SerializedApiError(statusCode, data) {
        var _this = _super.call(this) || this;
        _this.statusCode = statusCode;
        _this.data = data;
        _this.isSerializedApiError = true;
        return _this;
    }
    return SerializedApiError;
}(SerializedError));
exports.SerializedApiError = SerializedApiError;
/**
 * Type guard to check if the thrown error is an UnexpectedClientError
 */
exports.isUnexpectedClientError = function (error) {
    return error.name === UnexpectedClientError.name;
};
/**
 * Thrown if an unexpected error occurs in the client
 */
var UnexpectedClientError = /** @class */ (function (_super) {
    __extends(UnexpectedClientError, _super);
    function UnexpectedClientError(cause) {
        var _this = _super.call(this) || this;
        _this.cause = cause;
        _this.name = 'UnexpectedClientError';
        return _this;
    }
    return UnexpectedClientError;
}(SerializedError));
exports.UnexpectedClientError = UnexpectedClientError;
/**
 * Type guard to check if the thrown error is a ProjectionNotFound
 */
exports.isProjectionDefinitionNotFound = function (error) {
    return error.name === 'ProjectionDefinitionNotFound';
};
/**
 * Thrown when calling projection definition endpoints for a projection definition that does not exist.
 */
var ProjectionDefinitionNotFound = /** @class */ (function (_super) {
    __extends(ProjectionDefinitionNotFound, _super);
    function ProjectionDefinitionNotFound(projectionName) {
        var _this = _super.call(this, 404) || this;
        _this.projectionName = projectionName;
        _this.name = 'ProjectionDefinitionNotFound';
        return _this;
    }
    return ProjectionDefinitionNotFound;
}(SerializedApiError));
exports.ProjectionDefinitionNotFound = ProjectionDefinitionNotFound;
/**
 * Type guard to check if the thrown error is a ProjectionNotFound
 */
exports.isProjectionNotFound = function (error) {
    return error.name === 'ProjectionNotFound';
};
/**
 * Thrown when trying to load a projection that does not exist.
 */
var ProjectionNotFound = /** @class */ (function (_super) {
    __extends(ProjectionNotFound, _super);
    function ProjectionNotFound(projectionName, projectionId) {
        var _this = _super.call(this, 404) || this;
        _this.projectionName = projectionName;
        _this.projectionId = projectionId;
        _this.name = 'ProjectionNotFound';
        return _this;
    }
    return ProjectionNotFound;
}(SerializedApiError));
exports.ProjectionNotFound = ProjectionNotFound;
/**
 * Type guard to check if the thrown error is a AggregateNotFound
 */
exports.isAggregateNotFound = function (error) {
    return error.name === AggregateNotFound.name;
};
/**
 * Thrown when trying to load an aggregate that does not exist.
 */
var AggregateNotFound = /** @class */ (function (_super) {
    __extends(AggregateNotFound, _super);
    function AggregateNotFound(aggregateType, aggregateId) {
        var _this = _super.call(this, 404) || this;
        _this.aggregateType = aggregateType;
        _this.aggregateId = aggregateId;
        _this.name = AggregateNotFound.name;
        return _this;
    }
    return AggregateNotFound;
}(SerializedApiError));
exports.AggregateNotFound = AggregateNotFound;
/**
 * Type guard to check if the thrown error is a StateLoadingError
 */
exports.isStateLoadingError = function (error) {
    return error.name === 'StateLoadingError';
};
/**
 * Thrown by the aggregate client when the state loading of the Aggregate fails.
 */
var StateLoadingError = /** @class */ (function (_super) {
    __extends(StateLoadingError, _super);
    function StateLoadingError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'StateLoadingError';
        return _this;
    }
    return StateLoadingError;
}(SerializedError));
exports.StateLoadingError = StateLoadingError;
/**
 * Type guard to check if the thrown error is a ProjectionNotFound
 */
exports.isConfigurationError = function (error) {
    return error.name === 'ConfigurationError';
};
/**
 * Thrown when there is a configuration error in the client setup.
 */
var ConfigurationError = /** @class */ (function (_super) {
    __extends(ConfigurationError, _super);
    function ConfigurationError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'ConfigurationError';
        return _this;
    }
    return ConfigurationError;
}(SerializedError));
exports.ConfigurationError = ConfigurationError;
/**
 * Type guard to check if the thrown error is a ProjectionNotFound
 */
exports.isConflict = function (error) {
    return error.name === 'Conflict';
};
/**
 * Thrown when there is a version conflict when saving an aggregate using the expectedVersion argument. Either via the create or update methods in the AggregatesClient.
 */
var Conflict = /** @class */ (function (_super) {
    __extends(Conflict, _super);
    function Conflict(aggregateType, aggregateId, expectedVersion) {
        var _this = _super.call(this, 409) || this;
        _this.aggregateType = aggregateType;
        _this.aggregateId = aggregateId;
        _this.expectedVersion = expectedVersion;
        _this.name = 'Conflict';
        return _this;
    }
    return Conflict;
}(SerializedApiError));
exports.Conflict = Conflict;
/**
 * Type guard to check if the thrown error is a UnauthorizedError
 */
exports.isUnauthorizedError = function (error) {
    return error.name === 'UnauthorizedError';
};
/**
 * Thrown when using invalid access keys.
 */
var UnauthorizedError = /** @class */ (function (_super) {
    __extends(UnauthorizedError, _super);
    function UnauthorizedError(requestUrl) {
        var _this = _super.call(this, 401) || this;
        _this.requestUrl = requestUrl;
        _this.name = 'UnauthorizedError';
        return _this;
    }
    return UnauthorizedError;
}(SerializedApiError));
exports.UnauthorizedError = UnauthorizedError;
/**
 * Type guard to check if the thrown error is a RateLimitExceeded
 */
exports.isRateLimitExceeded = function (error) {
    return error.name === 'RateLimitExceeded';
};
/**
 * Thrown when you exceeded the rate limit for the current time period.
 */
var RateLimitExceeded = /** @class */ (function (_super) {
    __extends(RateLimitExceeded, _super);
    function RateLimitExceeded() {
        var _this = _super.call(this, 429) || this;
        _this.name = 'RateLimitExceeded';
        return _this;
    }
    return RateLimitExceeded;
}(SerializedApiError));
exports.RateLimitExceeded = RateLimitExceeded;
/**
 * Type guard to check if the thrown error is a ServiceUnavailable
 */
exports.isServiceUnavailable = function (error) {
    return error.name === 'ServiceUnavailable';
};
/**
 * Thrown when the API is temporarily unavailable for some reason.
 */
var ServiceUnavailable = /** @class */ (function (_super) {
    __extends(ServiceUnavailable, _super);
    function ServiceUnavailable(requestUrl) {
        var _this = _super.call(this, 503) || this;
        _this.requestUrl = requestUrl;
        _this.name = 'ServiceUnavailable';
        return _this;
    }
    return ServiceUnavailable;
}(SerializedApiError));
exports.ServiceUnavailable = ServiceUnavailable;
